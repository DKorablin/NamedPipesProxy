# Workflow Description:
# This workflow automates the build, signing, packaging, and release process for the NamedPipesProxy library.
# 
# Steps Overview:
# 1. Version/Tag Creation - Automatically generates a new version tag based on commit history (or uses manual input)
# 2. Strong-Name Key Decoding - Decodes the assembly signing key from secrets
# 3. .NET SDK Setup - Configures the .NET environment for building multi-target projects
# 4. NuGet Package Caching - Caches NuGet packages to speed up subsequent builds
# 5. Dependency Restoration - Restores all project dependencies
# 6. Multi-Target Build - Builds the project for .NET Framework 4.8, .NET Standard 2.1, and .NET 9
# 7. Binary Discovery - Locates compiled DLL files for code signing
# 8. Code Signing - Signs the compiled binaries with a certificate for authenticity
# 9. NuGet Package Creation - Creates NuGet packages (.nupkg) with symbols (.snupkg)
# 10. Package Deployment - Publishes packages to GitHub Packages (and optionally NuGet.org)
# 11. Artifact Zipping - Compresses build outputs for each target framework
# 12. GitHub Release - Creates a GitHub release with artifacts and changelog
# 13. Cleanup on Failure - Removes created tags if the build fails

name: Build, Release

on:
#  push:
#    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      dotNetVersion:
        description: 'Determine the version of .NET used to configure the environment'
        required: false
        default: '8.0.x'
      newVersion:
        description: 'Optionally specify a new version number (overrides automatic versioning)'
        required: false
        default: ''

permissions:
  contents: write      # Needed for creating releases and tags
  packages: write      # Needed for pushing to GitHub Packages
  id-token: write      # enable GitHub OIDC token issuance for this job

env:
  SolutionName: ${{github.event.repository.name}}
  DotNetVersion: ${{github.event.inputs.dotNetVersion || '8.0.x'}}
  ArtifactsDir: ${{github.workspace}}\bin\

jobs:
  version:
    name: Tag / Version
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{steps.tag_version.outputs.new_version}}
      new_tag: ${{steps.tag_version.outputs.new_tag}}
      changelog: ${{steps.tag_version.outputs.changelog}}
    steps:
    - name: Tag version
      id: tag_version
      uses: mathieudutour/github-tag-action@v6.2
      with:
        github_token: ${{secrets.GITHUB_TOKEN}}
        custom_tag: ${{github.event.inputs.newVersion}}

  build_net:
    name: Build
    needs: [version]
    runs-on: windows-latest
    steps:
    - name: Decoding strong-name key
      id: sign_key_file
      uses: timheuer/base64-to-file@v1.2
      with:
        fileName: 'Signature.snk'
        encodedString: ${{secrets.SIGN_ASM_KEY}}
    - uses: actions/checkout@v4
 
    - name: Setup .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{env.DotNetVersion}}
    - name: Caching NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Restore
      run: dotnet restore
    - name: Building multi-target project
      run: >
       dotnet build ${{env.SolutionName}}\${{env.SolutionName}}.csproj
       /p:configuration=Release --no-restore
       /p:BaseOutputPath="${{env.ArtifactsDir}}"
       /p:GenerateDocumentationFile=true
       /p:SignAssembly=true
       /p:Version=${{needs.version.outputs.new_version}}
       /p:AssemblyOriginatorKeyFile="${{steps.sign_key_file.outputs.filePath}}"
    - name: Listing release directory
      run: |
        echo "Listing files in the release directory:"
        ls ${{env.ArtifactsDir}}Release -Recurse
      shell: pwsh
    - name: Finding portable executables to sign
      id: find_binaries
      run: |
        $filePaths = Get-ChildItem -Path "${{env.ArtifactsDir}}Release" -Recurse -Include "${{env.SolutionName}}.dll" | ForEach-Object { $_.FullName }
        $multiLineString = $filePaths -join "`n"

        echo "Found files to sign:"
        echo $multiLineString

        echo "files_to_sign<<EOF" >> $env:GITHUB_OUTPUT
        echo $multiLineString >> $env:GITHUB_OUTPUT
        echo "EOF" >> $env:GITHUB_OUTPUT
      shell: pwsh
    - name: Signing portable executables
      uses: dlemstra/code-sign-action@v1
      with:
        certificate: '${{secrets.SIGN_PE_CERTIFICATE}}'
        password: '${{secrets.SIGN_PE_PASSWORD}}'
        recursive: false
        files: ${{steps.find_binaries.outputs.files_to_sign}}
    - name: Creating NuGet package
      run: >
        dotnet pack ${{env.SolutionName}}.slnx --no-build --no-restore -c Release -o ${{env.ArtifactsDir}}nupkg
        /p:PackageVersion=${{needs.version.outputs.new_version}}
        /p:GenerateDocumentationFile=true
        /p:IncludeSymbols=true
        /p:DebugType=Portable
        /p:EmbedUntrackedSources=true
        /p:PublishRepositoryUrl=true
        /p:EnablePackageValidation=true
        /p:SymbolPackageFormat=snupkg
#    - name: NuGet login (OIDC)
#      uses: NuGet/login@v1
#      id: login
#      with:
#        user: ${{secrets.NUGET_USER}}
    - name: Deploying package to GitHub (Only nupkg because snupkg is not supported by GitHub)
      run: dotnet nuget push ${{env.ArtifactsDir}}nupkg\*.nupkg --skip-duplicate --api-key ${{secrets.GITHUB_TOKEN}} --source https://nuget.pkg.github.com/DKorablin/index.json
#    - name: Deploying package to NuGet
#      run: dotnet nuget push ${{env.ArtifactsDir}}nupkg\*.nupkg --skip-duplicate --api-key ${{steps.login.outputs.NUGET_API_KEY}} --source https://api.nuget.org/v3/index.json
#TODO: This step is not working. Because PE files are changed after PE certificate injected. So symbols do not match.
#    There is only one solution possible for the time being: - Inject PDB inside PE files on build (DebugType=Embedded) but I don't like this approach
#    - name: Deploying SourceLink package to NuGet
#      run: dotnet nuget push ${{env.ArtifactsDir}}nupkg\*.snupkg --skip-duplicate --api-key ${{steps.login.outputs.NUGET_API_KEY}} --source https://api.nuget.org/v3/index.json
    - name: Zipping artifacts
      run: |
        $basePath = "${{env.ArtifactsDir}}Release"
        Get-ChildItem -Path $basePath -Directory | ForEach-Object {
          $dirName = $_.Name
          echo "Creating archive for $dirName"
          $archiveName = "${{env.SolutionName}}_v${{needs.version.outputs.new_version}}_${dirName}.zip"
          $destinationPath = Join-Path -Path $basePath -ChildPath $archiveName
          Compress-Archive -Path "$($_.FullName)\*" -DestinationPath $destinationPath -Force
        }
      shell: pwsh
    - name: Publish GitHub Release
      uses: ncipollo/release-action@v1
      with:
        artifacts: ${{env.ArtifactsDir}}Release\*.zip
        tag: ${{needs.version.outputs.new_tag}}
        name: Auto ${{needs.version.outputs.new_tag}}
        body: ${{needs.version.outputs.changelog}}
        artifactErrorsFailBuild: true
        generateReleaseNotes: true

  failure_cleanup:
    name: Cleanup Tag On Failure
    needs: [version, build_net]
    if: always() && needs.build_net.result != 'success'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: false
        fetch-depth: 0
    - name: Remove created tag
      run: |
        git tag -d ${{needs.version.outputs.new_tag}} || true
        git push origin :refs/tags/${{needs.version.outputs.new_tag}} || true